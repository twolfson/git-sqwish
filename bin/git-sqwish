#!/bin/sh

# Rename variables
master="$1"
message="$2"

# If no master branch is provided, complain and leave
if test -z $master; then
  echo "Master branch required." 1>&2
  exit 1
fi

# Determine the starting branch
original="$(git symbolic-ref --short HEAD)"

# If the working directory is dirty, complain and leave
clean_status() {
  git status --porcelain
}
if test -n "$(clean_status)"; then
  echo "Working directory is dirty. Please stash or commit changes." 1>&2
  exit 1
fi

# Pull down changes from master
git merge $master --no-commit --no-ff 1> /dev/null 2> /dev/null

# If the branch is dirty
if test -n "$(clean_status)"; then
  # Clean up changes
  git reset --hard 1> /dev/null 2> /dev/null

  # Complain and leave
  echo "This branch is not up-to-date with $master. Please merge in changes." 1>&2
  exit 1
fi

# Move to a sqwished branch based off of master
git checkout -B $original.sqwished $master 1> /dev/null 2> /dev/null

# Pull over all files from original branch
git checkout $original -- . 1> /dev/null 2> /dev/null

# If there is a message, commit files with message and past commits
if test -n "$message"; then
  # Collect the commit message of those in $original but not in $master (since..until)
  past_commits="$(git log $master..$original --format='%s')"

  # Automatically commit with message (subject) and past_commits (body)
  git commit -F- <<EOF
$message

$past_commits
EOF
else
# Otherwise, open a pre-filled commit dialog (via .git/MERGE_MSG)
  cat <<EOF > .git/MERGE_MSG
# Please write a subject for your commit
# If you don't, the subject will become the first log below

# Below are your previous commit messages
# These will become the body of the commit
EOF
  git log $master..$original --format="%s" | \
  while read log; do
    echo $log
  done

  # git commit
fi
