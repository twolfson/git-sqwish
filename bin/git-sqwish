#!/bin/sh

# Rename variables
master="$1"
message="$2"

# If no master branch is provided, complain and leave
test -z $master && echo "Master branch required." 1>&2 && exit 1

# Determine the starting branch
original=$(git symbolic-ref --short HEAD)

# If the working directory is dirty, complain and leave
clean_status() {
  git status --porcelain
}
test -n "$(clean_status)" && echo "Working directory is dirty. Please stash or commit changes." 1>&2 && exit 1

# Pull down changes from master
git merge --no-commit --no-ff $master 1> /dev/null 2> /dev/null

# If the branch is dirty
if test -n "$(clean_status)"; then
  # Clean up changes
  git reset --hard 1> /dev/null 2> /dev/null

  # Complain and leave
  echo "This branch is not up-to-date with $master. Please merge in changes." 1>&2
  exit 1
fi

# Move to a squashed branch based off of master
cat message.txt
git checkout -B $original.squashed $master 1> /dev/null 2> /dev/null
git log --format=oneline
cat message.txt

# Pull over all files from original branch
git merge $original --no-commit --no-ff 1> /dev/null 2> /dev/null
cat message.txt
echo $original
git log --format=oneline
git reset .
git merge --abort
git status

# Collect the commit message of those in $original but not in $master (since..until)
git log $master..$original --format=format:%s > .git/MERGE_MSG

# If there is a message, commit files with input and aggregate messages
if test -n "$message"; then
  # Read in the message to memory and delete it
  aggregate=$(cat .git/MERGE_MSG)
  rm .git/MERGE_MSG

  # Automatically commit with input and aggergate messages
  git commit -F- <<EOF
$message
$aggregate
EOF
else
# Otherwise, open a pre-filled commit dialog (via .git/MERGE_MSG)
  git commit
fi

# Delete backup branch
git branch -D $temporary 1> /dev/null 2> /dev/null
